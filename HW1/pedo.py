# -*- coding: utf-8 -*-
"""pedo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CUPKFSUyz_kqxxPortCWPoG6piO1wO9z
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os,re
from scipy.signal import butter, filtfilt

  # Function to create a Butterworth low-pass filter
def butter_lowpass_filter(data, cutoff, fs, order=4):
    nyquist = 0.5 * fs  # Nyquist frequency
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    y = filtfilt(b, a, data)
    return y

def remove_gravity_full(data):

    filtered_data = np.zeros(len(data))
    gravAccel = np.mean(data)
    for i in range(len(data)):
        filtered_data[i] = data[i] - gravAccel # gravity

    return filtered_data

def peak_finding_3(data, window_size=100, step_size=50,
                   up_percentile=85, low_percentile=40,
                   global_up_threshold=None, global_low_threshold=None,
                   minimum_distance=25):

    """
    Finds peaks in the data using a sliding window approach with dynamically
    determined thresholds and global thresholds as a fallback mechanism for noise suppression.

    Parameters:
    - data: the accelerometer data (1D numpy array or list)
    - window_size: size of each sliding window
    - step_size: step size for the sliding window (overlap is window_size - step_size)
    - up_percentile: percentile for determining the upper threshold within a window (e.g., 85 for 85th percentile)
    - low_percentile: percentile for determining the lower threshold within a window (e.g., 40 for 40th percentile)
    - global_up_threshold: an absolute global upper threshold to ignore small peaks in periods of inactivity
    - global_low_threshold: an absolute global lower threshold for resetting during inactivity periods
    - minimum_distance: minimum distance between consecutive peaks (in number of samples)

    Returns:
    - List of indices where peaks are detected
    - List of upper and lower threshold values per window for plotting
    """
    hard_limit = 1
    steps = []  # to store the indices of detected peaks
    temp_peak = None  # Temporarily store a peak until validated
    reset = True  # Indicates whether we are ready to register a new peak
    local_upper_thresholds = []  # Store local upper thresholds for plotting
    local_lower_thresholds = []  # Store local lower thresholds for plotting
    window_positions = []  # Store positions of each window for plotting

    # Calculate global thresholds if not provided
    if global_up_threshold is None:
        global_up_threshold = np.percentile(data, 80)  # Upper bound on what is a peak
    if global_low_threshold is None:
        global_low_threshold = np.percentile(data, 50)  # Higher value, must dip below this for new peak detection

    print(f"Global upper threshold: {global_up_threshold}")
    print(f"Global lower threshold: {global_low_threshold}")

    # Loop over the data in steps, using a sliding window
    for start in range(0, len(data) - window_size + 1, step_size):
        window_data = data[start:start + window_size]  # extract the current window

        # Calculate dynamic window-based thresholds
        local_up_threshold = np.percentile(window_data, up_percentile)
        local_low_threshold = np.percentile(window_data, low_percentile)

        # Store local thresholds and window position for later plotting
        local_upper_thresholds.append((start, start + window_size, local_up_threshold))
        local_lower_thresholds.append((start, start + window_size, local_low_threshold))
        window_positions.append(start)

        # Loop through the window to find peaks
        for i in range(1, len(window_data) - 1):
            global_index = start + i  # position in the original data

            # Check if it's a local peak
            if window_data[i] > window_data[i - 1] and window_data[i] > window_data[i + 1]:
                # Peak detection based on local thresholds
                if window_data[i] > local_up_threshold:
                    # Allow peak only if it is above the global upper threshold
                    if window_data[i] > global_up_threshold and reset and (window_data[i]>hard_limit):
                        # Check the minimum distance condition
                        if len(steps) == 0 or (global_index - steps[-1] >= minimum_distance):
                            if temp_peak is None:
                                temp_peak = global_index  # Temporarily store this peak
                            elif data[global_index] > data[temp_peak]:
                                # If this peak is higher than the stored one, replace it
                                temp_peak = global_index

            # Reset condition: data must first cross the global lower threshold
            if window_data[i] < global_low_threshold:
                # After crossing the global lower threshold, check local lower threshold to reset
                if window_data[i] < local_low_threshold:
                    reset = True  # Re-enable peak detection
                    # If we had a temporarily stored peak, validate it
                    if temp_peak is not None:
                        steps.append(temp_peak)  # Confirm the temp peak as a valid step
                        temp_peak = None  # Clear the temporary peak

    # If there is a temporary peak stored at the end, add it to the steps
    if temp_peak is not None:
        steps.append(temp_peak)
    return steps, local_upper_thresholds, local_lower_thresholds, global_up_threshold, global_low_threshold

def count_steps(file_name,interval=100.0):

  data = pd.read_csv(file_name, delimiter= ",")

  filt_data_z = remove_gravity_full(data['z'])
  filt_data_x = remove_gravity_full(data['x'])
  filt_data_y = remove_gravity_full(data['y'])
  # Gravity is removed
  filtered_magnitude= np.sqrt(filt_data_x**2 +filt_data_y**2 +filt_data_z**2)

  # Let's define the sampling rate (samples per second)
  sampling_rate = interval  # Example, adjust to your actual sensor sampling rate
  cutoff_frequency = 5  # Cutoff frequency at 5 Hz in the frequency domain

  # Step 1: Perform FFT on the original data
  fft_result_original = np.fft.fft(filtered_magnitude)
  n = len(filtered_magnitude)  # Number of data points
  frequencies = np.fft.fftfreq(n, 1 / sampling_rate)
  magnitude_original = np.abs(fft_result_original)

  # Step 2: Apply the low-pass filter with 5 Hz cutoff frequency in the frequency domain
  filtered_data = butter_lowpass_filter(filtered_magnitude, cutoff_frequency, sampling_rate)

  # Step 3: Perform FFT on the filtered data
  fft_result_filtered = np.fft.fft(filtered_data)
  magnitude_filtered = np.abs(fft_result_filtered)

  # Step 4: Plot both the original and filtered FFT results

  plt.figure(figsize=(14, 6))

  # Plot FFT of the original signal
  plt.subplot(1, 2, 1)
  plt.plot(frequencies[:n//2], magnitude_original[:n//2])  # Only positive frequencies
  plt.title("Original Frequency Spectrum")
  plt.xlabel("Frequency (Hz)")
  plt.ylabel("Magnitude")
  plt.grid(True)

  # Plot FFT of the filtered signal
  plt.subplot(1, 2, 2)
  plt.plot(frequencies[:n//2], magnitude_filtered[:n//2])  # Only positive frequencies
  plt.title("Filtered Frequency Spectrum (5 Hz LPF)")
  plt.xlabel("Frequency (Hz)")
  plt.ylabel("Magnitude")
  plt.grid(True)

  plt.tight_layout()
  plt.show()

  peaks_full, local_up_ths, local_low_ths, global_up_th, global_low_th = peak_finding_3(filtered_data)

  step_count_full = len(peaks_full)

  print(f"Filtered Step Count is: {step_count_full}")

  plt.figure(figsize=(16, 6))

  # Plot global thresholds
  plt.axhline(global_up_th, color='red', linestyle='--', label='Global Upper Threshold')
  plt.axhline(global_low_th, color='blue', linestyle='--', label='Global Lower Threshold')

  # Plot local thresholds per window
  for (start, end, th) in local_up_ths:
      plt.plot([start, end], [th, th], color='green', linestyle='--', label='Local Upper Threshold' if start == 0 else "")

  for (start, end, th) in local_low_ths:
      plt.plot([start, end], [th, th], color='purple', linestyle='--', label='Local Lower Threshold' if start == 0 else "")

  # Plot for the second dataset
  plt.plot(filtered_data, label="Accelerometer_data")
  plt.plot(peaks_full, filtered_data[peaks_full], "x", label='Step_full')
  plt.title("Step Counting_full with Thresholds")
  plt.xlabel("Time")
  plt.ylabel("Magnitude")
  plt.legend()
  plt.grid(True)

  plt.show()

csvFiles = []

for items in os.listdir("."):
  if(re.search(r"\.csv$",items)):
    csvFiles.append(items)

for file in csvFiles:
  print(file)
  count_steps(file)